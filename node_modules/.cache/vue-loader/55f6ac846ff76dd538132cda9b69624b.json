{"remainingRequest":"/Users/dashuaige/artminda/myweb/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/dashuaige/artminda/myweb/src/components/3d_ball.vue?vue&type=style&index=0&id=482512e6&scoped=true&lang=css&","dependencies":[{"path":"/Users/dashuaige/artminda/myweb/src/components/3d_ball.vue","mtime":1593338198548},{"path":"/Users/dashuaige/artminda/myweb/node_modules/css-loader/index.js","mtime":499162500000},{"path":"/Users/dashuaige/artminda/myweb/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/dashuaige/artminda/myweb/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/dashuaige/artminda/myweb/node_modules/vuetify-loader/lib/loader.js","mtime":1564062719000},{"path":"/Users/dashuaige/artminda/myweb/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/dashuaige/artminda/myweb/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#container {\n  display: block;\n  width: 1000px;\n  height: 400px;\n  margin: 0 auto;\n  padding: 0;\n  overflow: hidden;\n}\n",{"version":3,"sources":["3d_ball.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"3d_ball.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\n// import Stats from \"./stats.module.js\";\n// import { GUI } from \"./dat.gui.module.js\";\n// import { OrbitControls } from './OrbitControls.js';\nimport { OBJLoader, MTLLoader } from \"three-obj-mtl-loader\";\n// import MTLLoader from  'three-mtl-loader';\n// import OBJLoader from  'three-obj-loader';\nimport { CSS2DRenderer, CSS2DObject } from \"three-css2drender\";\nconst OrbitControls = require(\"three-orbit-controls\")(THREE);\n\nexport default {\n  name: \"Home\",\n  data() {\n    return {\n      group: \"\",\n      container:\"\",\n      stats: \"\",\n      particlesData: [],\n      camera: \"\",\n      scene: \"\",\n      renderer: \"\",\n      positions:\"\",\n      colors: \"\",\n      particles: \"\",\n      pointCloud: \"\",\n      particlePositions: \"\",\n      linesMesh: \"\",\n      maxParticleCount: 1000,\n      particleCount: 300,\n      r: 800,\n      rHalf: 100 / 2,\n      effectController:{\n        showDots: false,\n        showLines: true,\n        minDistance: 150,\n        limitConnections: false,\n        maxConnections: 8,\n        particleCount: 345\n      }\n    }\n  },\n  methods: {\n    // initGUI(){\n    //   var gui = new GUI();\n\n    //   gui.add(this.effectController, this.effectController.showDots).onChange(function(value) {\n    //     pointCloud.visible = value;\n    //   });\n    //   gui.add(this.effectController, this.effectController.showLines).onChange(function(value) {\n    //     linesMesh.visible = value;\n    //   });\n    //   gui.add(this.effectController, this.effectController.minDistance, 10, 300);\n    //   gui.add(this.effectController, this.effectController.limitConnections);\n    //   gui.add(this.effectController, this.effectController.maxConnections, 0, 30, 1);\n    //   gui\n    //     .add(this.effectController, this.effectController.particleCount, 0, maxParticleCount, 1)\n    //     .onChange(function(value) {\n    //       particleCount = parseInt(value);\n    //       particles.setDrawRange(0, particleCount);\n    //     });\n    // },\n\n    init() {\n    //   this.initGUI();\n\n      this.container = document.getElementById(\"container\");\n\n      this.camera = new THREE.PerspectiveCamera(\n        60,\n        window.innerWidth / window.innerHeight,\n        1,\n        4000\n      );\n      this.camera.position.z = 2000;\n   \n      var controls = new OrbitControls(this.camera, this.container);\n\n      this.scene = new THREE.Scene();\n\n      this.group = new THREE.Group();\n      this.scene.add(this.group);\n\n      var helper = new THREE.BoxHelper(\n        new THREE.Mesh(new THREE.BoxBufferGeometry(this.r, this.r, this.r))\n      );\n      helper.material.color.setHex(0x101010);\n      helper.material.blending = THREE.AdditiveBlending;\n      helper.material.transparent = true;\n      this.group.add(helper);\n\n      var segments = this.maxParticleCount * this.maxParticleCount;\n\n      this.positions = new Float32Array(segments * 3);\n      this.colors = new Float32Array(segments * 3);\n\n      var pMaterial = new THREE.PointsMaterial({\n        color: 0x222222,\n        size: 3,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        sizeAttenuation: false\n      });\n\n      this.particles = new THREE.BufferGeometry();\n      this.particlePositions = new Float32Array(this.maxParticleCount * 3);\n\n      for (var i = 0; i < this.maxParticleCount; i++) {\n        var x = Math.random() *this.r-this.r/ 2;\n        var y = Math.random() *this.r-this.r/ 2;\n        var z = Math.random() *this.r-this.r/ 2;\n\n        this.particlePositions[i * 3] = x;\n        this.particlePositions[i * 3 + 1] = y;\n        this.particlePositions[i * 3 + 2] = z;\n\n        // add it to the geometry\n        this.particlesData.push({\n          velocity: new THREE.Vector3(\n            -1 + Math.random() * 2,\n            -1 + Math.random() * 2,\n            -1 + Math.random() * 2\n          ),\n          numConnections: 0\n        });\n      }\n\n      this.particles.setDrawRange(0, this.particleCount);\n      this.particles.setAttribute(\n        \"position\",\n        new THREE.BufferAttribute(this.particlePositions, 3).setUsage(\n          THREE.DynamicDrawUsage\n        )\n      );\n\n      // create the particle system\n      this.pointCloud = new THREE.Points(this.particles, pMaterial);\n      this.group.add(this.pointCloud);\n\n      var geometry = new THREE.BufferGeometry();\n\n      geometry.setAttribute(\n        \"position\",\n        new THREE.BufferAttribute(this.positions, 3).setUsage(THREE.DynamicDrawUsage)\n      );\n      geometry.setAttribute(\n        \"color\",\n        new THREE.BufferAttribute(this.colors, 3).setUsage(THREE.DynamicDrawUsage)\n      );\n\n      geometry.computeBoundingSphere();\n\n      geometry.setDrawRange(0, 0);\n\n\n      var material = new THREE.LineBasicMaterial({\n        vertexColors: THREE.VertexColors,\n        blending: THREE.AdditiveBlending,\n        transparent: true\n      });\n\n      this.linesMesh = new THREE.LineSegments(geometry, material);\n      this.group.add(this.linesMesh);\n\n      //\n\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setPixelRatio(window.devicePixelRatio);\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n      this.renderer.outputEncoding = THREE.sRGBEncoding;\n\n      this.container.appendChild(this.renderer.domElement);\n\n      //\n\n    //   this.stats = new Stats();\n    //   this.container.appendChild(this.stats.dom);\n\n      window.addEventListener(\"resize\", this.onWindowResize, false);\n    },\n\n    onWindowResize() {\n      this.camera.aspect = window.innerWidth / window.innerHeight;\n      this.camera.updateProjectionMatrix();\n\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n    },\n\n    animate() {\n      var vertexpos = 0;\n      var colorpos = 0;\n      var numConnected = 0;\n\n      for (var i = 0; i < this.particleCount; i++)\n        this.particlesData[i].numConnections = 0;\n\n      for (var i = 0; i < this.particleCount; i++) {\n        // get the particle\n        var particleData = this.particlesData[i];\n\n        this.particlePositions[i * 3] += particleData.velocity.x;\n        this.particlePositions[i * 3 + 1] += particleData.velocity.y;\n        this.particlePositions[i * 3 + 2] += particleData.velocity.z;\n\n        if (\n          this.particlePositions[i * 3 + 1] < -this.rHalf ||\n          this.particlePositions[i * 3 + 1] > this.rHalf\n        )\n          particleData.velocity.y = -particleData.velocity.y;\n\n        if (\n          this.particlePositions[i * 3] < -this.rHalf ||\n          this.particlePositions[i * 3] > this.rHalf\n        )\n          particleData.velocity.x = -particleData.velocity.x;\n\n        if (\n          this.particlePositions[i * 3 + 2] < -this.rHalf ||\n          this.particlePositions[i * 3 + 2] > this.rHalf\n        )\n          particleData.velocity.z = -particleData.velocity.z;\n\n        if (\n          this.effectController.limitConnections &&\n          particleData.numConnections >= this.effectController.maxConnections\n        )\n          continue;\n\n        // Check collision\n        for (var j = i + 1; j < this.particleCount; j++) {\n          var particleDataB = this.particlesData[j];\n          if (\n            this.effectController.limitConnections &&\n            particleDataB.numConnections >= this.effectController.maxConnections\n          )\n            continue;\n\n          var dx = this.particlePositions[i * 3] - this.particlePositions[j * 3];\n          var dy = this.particlePositions[i * 3 + 1] - this.particlePositions[j * 3 + 1];\n          var dz = this.particlePositions[i * 3 + 2] - this.particlePositions[j * 3 + 2];\n          var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          if (dist < this.effectController.minDistance) {\n            particleData.numConnections++;\n            particleDataB.numConnections++;\n\n            var alpha = 1.0 - dist / this.effectController.minDistance;\n\n            this.positions[vertexpos++] = this.particlePositions[i * 3];\n            this.positions[vertexpos++] = this.particlePositions[i * 3 + 1];\n            this.positions[vertexpos++] = this.particlePositions[i * 3 + 2];\n\n            this.positions[vertexpos++] = this.particlePositions[j * 3];\n            this.positions[vertexpos++] = this.particlePositions[j * 3 + 1];\n            this.positions[vertexpos++] = this.particlePositions[j * 3 + 2];\n\n            this.colors[colorpos++] = alpha;\n            this.colors[colorpos++] = alpha;\n            this.colors[colorpos++] = alpha;\n\n            this.colors[colorpos++] = alpha;\n            this.colors[colorpos++] = alpha;\n            this.colors[colorpos++] = alpha;\n\n            numConnected++;\n          }\n        }\n      }\n\n      this.linesMesh.geometry.setDrawRange(0, numConnected * 2);\n      this.linesMesh.geometry.attributes.position.needsUpdate = true;\n      this.linesMesh.geometry.attributes.color.needsUpdate = true;\n\n      this.pointCloud.geometry.attributes.position.needsUpdate = true;\n\n      requestAnimationFrame(this.animate);\n\n    //   this.stats.update();\n      this.render();\n    },\n\n    render() {\n      var time = Date.now() * 0.001;\n\n      this.group.rotation.y = time * 0.1;\n      this.renderer.render(this.scene, this.camera);\n    }\n  },\n  mounted() {\n    this.init()\n    this.animate()\n  }\n};\n</script>\n<style scoped>\n#container {\n  display: block;\n  width: 1000px;\n  height: 400px;\n  margin: 0 auto;\n  padding: 0;\n  overflow: hidden;\n}\n</style>"]}]}